<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Untitled</title>
    

  </head>
    
  <body>
  <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Blocky v1.5</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            background-color: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
            background-color: #87CEEB;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* ================= MAIN MENU ================= */
        #menuScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
            overflow-y: auto;
            padding: 20px;
        }
        
        #menuContent {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .menuButton {
            width: 300px;
            height: 60px;
            background-color: white;
            color: black;
            border: none;
            margin: 10px 0;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            transition: background-color 0.2s;
        }
        
        .menuButton:hover {
            background-color: #ddd;
        }
        
        .menuButton:active {
            background-color: #aaa;
        }
        
        .worldEntry {
            width: 300px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            margin: 5px 0;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .worldEntry:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.02);
        }
        
        .worldEntry:active {
            background-color: rgba(255, 255, 255, 0.6);
        }
        
        #menuTitle {
            color: white;
            font-size: 36px;
            margin: 30px 0;
            text-align: center;
        }
        
        #worldList {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            max-height: 500px;
            overflow-y: auto;
            padding: 10px;
        }
        
        /* Scrollbar styling */
        #worldList::-webkit-scrollbar {
            width: 10px;
        }
        
        #worldList::-webkit-scrollbar-track {
            background: #333;
        }
        
        #worldList::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 5px;
        }
        
        #worldList::-webkit-scrollbar-thumb:hover {
            background: #888;
        }
        
        /* ================= GAME OVERLAY ================= */
        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        #healthBar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 4px;
            pointer-events: none;
        }
        
        .heart {
            width: 30px;
            height: 30px;
            background-color: red;
        }
        
        #saveButton {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 120px;
            height: 40px;
            background-color: rgba(50, 50, 200, 0.9);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        #saveButton:hover {
            background-color: rgba(70, 70, 220, 0.9);
        }
        
        #saveButton:active {
            background-color: rgba(30, 30, 180, 0.9);
        }
        
        #worldNameDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            border: 1px solid white;
            pointer-events: none;
            z-index: 10;
        }
        
        #timeDisplay {
            position: absolute;
            top: 70px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            border: 1px solid white;
            pointer-events: none;
            z-index: 10;
        }
        
        #inventoryContainer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            z-index: 10;
        }
        
        #inventory {
            display: flex;
            gap: 5px;
            background-color: rgba(150, 150, 150, 0.9);
            padding: 5px;
            border-radius: 5px;
            pointer-events: auto;
        }
        
        .inventorySlot {
            width: 60px;
            height: 60px;
            background-color: rgba(200, 200, 200, 0.9);
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .selectedSlot {
            box-shadow: 0 0 0 3px yellow;
            background-color: rgba(230, 230, 180, 0.9);
        }
        
        .itemCount {
            position: absolute;
            bottom: 2px;
            right: 5px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 0 black;
            pointer-events: none;
        }
        
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 5;
            pointer-events: none;
        }
        
        .controlBtn {
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 40px;
            opacity: 0.7;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: auto;
        }
        
        #craftingUI {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(50, 50, 50, 0.98);
            padding: 30px;
            border-radius: 10px;
            border: 4px solid #555;
            pointer-events: all;
            z-index: 30;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #craftingClose {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background-color: rgb(200, 50, 50);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
        }
        
        .craftingGrid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 20px;
            background-color: #8B5A2B;
            padding: 10px;
            border-radius: 5px;
        }
        
        .craftingSlot {
            width: 50px;
            height: 50px;
            background-color: rgb(121, 85, 58);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border: 2px solid #5D3A1A;
        }
        
        #craftingOutput {
            width: 60px;
            height: 60px;
            background-color: white;
            margin: 5px auto;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            border: 2px solid #5D3A1A;
        }
        
        .blockPreview {
            width: 36px;
            height: 36px;
            image-rendering: pixelated;
        }
        
        .craftingLayout {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        .versionBadge {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            opacity: 0.5;
            pointer-events: none;
            z-index: 1;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 25;
        }
        
        .gameOverContent {
            background-color: #333;
            padding: 40px;
            border-radius: 20px;
            border: 4px solid white;
            text-align: center;
        }
        
        .gameOverText {
            color: white;
            font-size: 48px;
            margin-bottom: 30px;
        }
        
        .restartButton {
            width: 200px;
            height: 60px;
            background-color: white;
            color: black;
            border: none;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 10px;
            margin: 0 auto;
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            .controlBtn {
                width: 80px;
                height: 80px;
            }
            
            .inventorySlot {
                width: 50px;
                height: 50px;
            }
            
            #inventoryContainer {
                bottom: 120px;
            }
            
            #saveButton {
                width: 100px;
                font-size: 14px;
            }
            
            #worldNameDisplay {
                font-size: 12px;
                padding: 5px 10px;
            }
            
            .craftingSlot {
                width: 40px;
                height: 40px;
            }
            
            #craftingOutput {
                width: 50px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Main Menu -->
        <div id="menuScreen">
            <div id="menuContent">
                <div id="menuTitle">2D Blocky v1.5</div>
                <div id="newWorldBtn" class="menuButton">NEW WORLD</div>
                <div id="worldList"></div>
            </div>
            <div class="versionBadge">v1.5 - Mobs, Caves & Day/Night</div>
        </div>
        
        <!-- Game Overlay -->
        <div id="gameOverlay" class="hidden">
            <div id="saveButton">SAVE & EXIT</div>
            <div id="worldNameDisplay"></div>
            <div id="timeDisplay"></div>
            <div id="healthBar"></div>
        </div>
        
        <!-- Inventory -->
        <div id="inventoryContainer" class="hidden">
            <div id="inventory"></div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls" class="hidden">
            <div id="leftBtn" class="controlBtn">‚Üê</div>
            <div id="rightBtn" class="controlBtn">‚Üí</div>
            <div id="jumpBtn" class="controlBtn">‚Üë</div>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden">
            <div class="gameOverContent">
                <div class="gameOverText">GAME OVER</div>
                <div id="restartBtn" class="restartButton">RESTART</div>
            </div>
        </div>
        
        <!-- Crafting UI - 3x3 Grid -->
        <div id="craftingUI" class="hidden">
            <div id="craftingClose">X</div>
            <div style="color: white; margin-bottom: 20px; text-align: center; font-size: 18px;">CRAFTING TABLE</div>
            
            <div class="craftingLayout">
                <!-- 3x3 Crafting Grid -->
                <div class="craftingGrid" id="craftingGrid">
                    <!-- Grid slots will be filled by JavaScript -->
                </div>
                
                <!-- Arrow -->
                <div style="color: white; font-size: 30px;">‚Üí</div>
                
                <!-- Output Slot -->
                <div>
                    <div id="craftingOutput"></div>
                </div>
            </div>
            
            <div style="color: #aaa; margin-top: 20px; font-size: 12px; text-align: center; max-width: 400px;">
                <strong>RECIPES:</strong><br>
                ‚Ä¢ Any Wood ‚Üí 4 Wooden Planks<br>
                ‚Ä¢ Wooden Plank + Wooden Plank (vertical) ‚Üí 2 Sticks<br>
                ‚Ä¢ Tall Grass ‚Üí 2 Short Grass<br>
                ‚Ä¢ Stone Pickaxe: ü™® top row + Sticks in middle/bottom center<br>
                ‚Ä¢ Iron Pickaxe: ‚öúÔ∏è top row + Sticks in middle/bottom center<br>
                ‚Ä¢ Gold Pickaxe: üèÖ top row + Sticks in middle/bottom center<br>
                ‚Ä¢ Diamond Pickaxe: üíé top row + Sticks in middle/bottom center
            </div>
        </div>
    </div>

    <script>
        // ================= CONFIG =================
        const WIDTH = 540;
        const HEIGHT = 960;
        const TILE = 32;
        const FPS = 60;

        // ================= COLORS =================
        const BROWN = [121, 85, 58];
        const GREEN = [95, 159, 53];
        const GRAY = [150, 150, 150];
        const WHITE = [255, 255, 255];
        const BLACK = [0, 0, 0];
        const BASE_SKY = [135, 206, 235];
        const RED = [255, 0, 0];
        
        // Ore colors
        const COAL_BLACK = [30, 30, 30];
        const IRON_GRAY = [180, 180, 180];
        const GOLD_YELLOW = [255, 215, 0];
        const DIAMOND_CYAN = [0, 255, 255];
        const STONE_GRAY = [120, 120, 120];
        
        // Mob colors
        const ZOMBIE_GREEN = [40, 80, 40];
        const ZOMBIE_EYES = [255, 0, 0];
        const SPIDER_RED = [150, 0, 0];
        const SPIDER_EYES = [255, 255, 0];
        const SHEEP_WHITE = [240, 240, 240];
        
        // Flower colors
        const ROSE_RED = [255, 0, 0];
        const ORANGE_TULIP = [255, 165, 0];
        const BLUE_TULIP = [0, 100, 255];
        const LILY_WHITE = [255, 255, 255];
        const GRASS_GREEN = [34, 139, 34];
        const TALL_GRASS_GREEN = [0, 100, 0];
        const STEM_GREEN = [0, 100, 0];

        // ================= GAME STATE =================
        let gameState = 'MENU'; // MENU, PLAYING, GAME_OVER
        let canvas, ctx;
        let player = {};
        let terrain = {};
        let vegetation = {};
        let mobs = [];
        let heights = {};
        let drops = [];
        let inventory = [];
        let selectedSlot = null;
        let breaking = null;
        let breakStartTime = 0;
        let breakingType = null;
        let craftingActive = false;
        
        // 3x3 crafting grid (9 slots)
        let craftingInputs = [
            null, null, null,
            null, null, null,
            null, null, null
        ];
        let craftingOutput = null;
        let gameTime = 0;
        let dayStartTime = 0;
        const DAY_LENGTH = 900; // 15 minutes in seconds
        let health = 10;
        let gameOver = false;
        let camera = {x: 0, y: 0};
        let mouse = {x: 0, y: 0, down: false};
        let attackCooldown = 0;
        
        // World management
        let worlds = [];
        let currentWorldId = null;
        
        // Load worlds from localStorage
        function loadWorlds() {
            const savedWorlds = localStorage.getItem('blockyWorlds');
            if (savedWorlds) {
                worlds = JSON.parse(savedWorlds);
            } else {
                worlds = [];
            }
            updateWorldList();
        }
        
        // Save worlds to localStorage
        function saveWorlds() {
            localStorage.setItem('blockyWorlds', JSON.stringify(worlds));
            updateWorldList();
        }
        
        // Generate random world name
        function generateWorldName() {
            const nameLength = Math.floor(Math.random() * 3) + 4;
            let name = '';
            
            const patterns = [
                'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                '123456789',
                'abcdefghijklmnopqrstuvwxyz',
                '0123456789',
                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            ];
            
            for (let i = 0; i < nameLength; i++) {
                const patternIndex = Math.floor(Math.random() * patterns.length);
                const pattern = patterns[patternIndex];
                const randomChar = pattern[Math.floor(Math.random() * pattern.length)];
                name += randomChar;
            }
            
            if (Math.random() < 0.3) {
                const extraPattern = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
                const extraChar = extraPattern[Math.floor(Math.random() * extraPattern.length)];
                name += extraChar;
            }
            
            return name;
        }
        
        // Create new world
        function createNewWorld() {
            let worldName = generateWorldName();
            
            let attempts = 0;
            while (worlds.some(w => w.name === worldName) && attempts < 100) {
                worldName = generateWorldName();
                attempts++;
            }
            
            const worldId = Date.now().toString() + Math.random().toString(36);
            const newWorld = {
                id: worldId,
                name: worldName,
                player: { ...player },
                terrain: { ...terrain },
                vegetation: { ...vegetation },
                heights: { ...heights },
                inventory: JSON.parse(JSON.stringify(inventory)),
                health: health,
                dayStartTime: dayStartTime,
                camera: { ...camera },
                createdAt: Date.now()
            };
            
            worlds.push(newWorld);
            saveWorlds();
            return worldId;
        }
        
        // Save current world
        function saveCurrentWorld() {
            if (!currentWorldId) return;
            
            const worldIndex = worlds.findIndex(w => w.id === currentWorldId);
            if (worldIndex !== -1) {
                worlds[worldIndex] = {
                    ...worlds[worldIndex],
                    player: { ...player },
                    terrain: { ...terrain },
                    vegetation: { ...vegetation },
                    heights: { ...heights },
                    inventory: JSON.parse(JSON.stringify(inventory)),
                    health: health,
                    dayStartTime: dayStartTime,
                    camera: { ...camera },
                    lastSaved: Date.now()
                };
                saveWorlds();
                
                const saveBtn = document.getElementById('saveButton');
                saveBtn.style.backgroundColor = 'rgba(0, 200, 0, 0.9)';
                saveBtn.textContent = 'SAVED!';
                
                setTimeout(() => {
                    saveBtn.style.backgroundColor = 'rgba(50, 50, 200, 0.9)';
                    saveBtn.textContent = 'SAVE & EXIT';
                    
                    returnToMenu();
                }, 500);
            }
        }
        
        // Return to main menu
        function returnToMenu() {
            gameState = 'MENU';
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('gameOverlay').classList.add('hidden');
            document.getElementById('inventoryContainer').classList.add('hidden');
            document.getElementById('mobileControls').classList.add('hidden');
            document.getElementById('craftingUI').classList.add('hidden');
            craftingActive = false;
            updateWorldList();
        }
        
        // Load world by ID
        function loadWorld(worldId) {
            const world = worlds.find(w => w.id === worldId);
            if (!world) return false;
            
            player = { ...world.player };
            terrain = { ...world.terrain };
            vegetation = { ...world.vegetation };
            heights = { ...world.heights };
            inventory = JSON.parse(JSON.stringify(world.inventory));
            health = world.health;
            dayStartTime = world.dayStartTime;
            camera = { ...world.camera };
            currentWorldId = worldId;
            
            updateInventoryUI();
            updateHealthUI();
            document.getElementById('worldNameDisplay').textContent = world.name;
            
            return true;
        }
        
        // Update world list UI
        function updateWorldList() {
            const worldList = document.getElementById('worldList');
            worldList.innerHTML = '';
            
            const sortedWorlds = [...worlds].sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
            
            for (const world of sortedWorlds) {
                const worldEntry = document.createElement('div');
                worldEntry.className = 'worldEntry';
                worldEntry.textContent = world.name;
                worldEntry.addEventListener('click', () => {
                    if (loadWorld(world.id)) {
                        startGame();
                    }
                });
                worldList.appendChild(worldEntry);
            }
        }
        
        // ================= DAMAGE TABLE =================
        const damageTable = {
            1:0, 2:0, 3:1, 4:2, 5:2.5, 6:3, 7:3.5, 8:4, 9:4.5, 10:5, 
            11:6, 12:7, 13:8, 14:9, 15:10
        };
        
        // ================= ORE TYPES (Need Pickaxe) =================
        const ORE_TYPES = {
            'coal_ore': {
                drop: 'coal',
                breakTime: 7.5,
                color: COAL_BLACK
            },
            'iron_ore': {
                drop: 'iron',
                breakTime: 12,
                color: IRON_GRAY
            },
            'gold_ore': {
                drop: 'gold',
                breakTime: 15.5,
                color: GOLD_YELLOW
            },
            'diamond_ore': {
                drop: 'diamond',
                breakTime: 30,
                color: DIAMOND_CYAN
            }
        };
        
        // ================= STONE (Collectible with hands) =================
        const STONE_BLOCK = {
            'stone': {
                drop: 'stone',
                breakTime: 10,
                color: STONE_GRAY
            }
        };
        
        // ================= PICKAXE TYPES =================
        const PICKAXE_TYPES = {
            'stone_pickaxe': { 
                tier: 'basic', 
                material: 'stone',
                speedMultiplier: 5.0
            },
            'iron_pickaxe': { 
                tier: 'basic', 
                material: 'iron',
                speedMultiplier: 5.0
            },
            'gold_pickaxe': { 
                tier: 'high', 
                material: 'gold',
                speedMultiplier: 7.5
            },
            'diamond_pickaxe': { 
                tier: 'ultra', 
                material: 'diamond',
                speedMultiplier: 12.5
            }
        };
        
        // ================= DAY/NIGHT CYCLE =================
        function getTimeOfDay() {
            return (Date.now() / 1000 - dayStartTime) % DAY_LENGTH;
        }
        
        function getBrightness() {
            const timeInCycle = getTimeOfDay();
            
            if (timeInCycle < 300) {
                return 1.0; // Full Day - 100%
            } else if (timeInCycle < 600) {
                return 0.75; // Sunset - 75%
            } else {
                return 0.3; // Night - 30%
            }
        }
        
        function getSkyColor() {
            const timeInCycle = getTimeOfDay();
            const brightness = getBrightness();
            
            if (timeInCycle < 300) {
                // Day - Light blue
                return [135 * brightness, 206 * brightness, 235 * brightness];
            } else if (timeInCycle < 600) {
                // Sunset - Darker blue
                return [100 * brightness, 150 * brightness, 200 * brightness];
            } else {
                // Night - Dark blue
                return [30 * brightness, 40 * brightness, 80 * brightness];
            }
        }
        
        function isDay() {
            return getTimeOfDay() < 300;
        }
        
        function isNight() {
            return getTimeOfDay() >= 600;
        }
        
        function updateTimeDisplay() {
            const timeInCycle = getTimeOfDay();
            const minutes = Math.floor(timeInCycle / 60);
            const seconds = Math.floor(timeInCycle % 60);
            let phase = '';
            
            if (timeInCycle < 300) phase = 'DAY';
            else if (timeInCycle < 600) phase = 'SUNSET';
            else phase = 'NIGHT';
            
            document.getElementById('timeDisplay').textContent = `${phase} ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // ================= CAVE GENERATION =================
        function generateCaveAt(x, y) {
            if (y < 30) return false; // Caves only at depth >= 30
            
            // 5% chance to generate cave
            if (Math.random() > 0.05) return false;
            
            const caveSize = Math.random() < 0.7 ? 
                Math.floor(Math.random() * 15) + 30 : // Small cave: 30-45 blocks
                Math.floor(Math.random() * 20) + 60;  // Large cave: 60-80 blocks
            
            let currentX = x;
            let currentY = y;
            
            for (let i = 0; i < caveSize; i++) {
                // Random walk
                currentX += Math.floor(Math.random() * 3) - 1;
                currentY += Math.floor(Math.random() * 3) - 1;
                
                // Carve out area
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const caveX = currentX + dx;
                        const caveY = currentY + dy;
                        const key = `${caveX},${caveY}`;
                        
                        if (terrain[key] === 'stone' || terrain[key]?.includes('_ore')) {
                            terrain[key] = 'air';
                        }
                    }
                }
            }
            
            return true;
        }
        
        // ================= MOB SYSTEM =================
        class Mob {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 44;
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.health = this.getMaxHealth();
                this.speed = 2; // blocks per second
                this.chaseRange = 15;
                this.attackRange = 3;
                this.attackDamage = this.getAttackDamage();
                this.state = 'idle';
                this.despawnTimer = 0;
                this.lastPlayerX = 0;
                this.lastPlayerY = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.wanderTimer = 0;
            }
            
            getMaxHealth() {
                switch(this.type) {
                    case 'zombie': return 4;
                    case 'spider': return 2.5;
                    case 'sheep': return 3;
                    default: return 1;
                }
            }
            
            getAttackDamage() {
                switch(this.type) {
                    case 'zombie': return 1;
                    case 'spider': return 0.5;
                    default: return 0;
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    return true;
                }
                return false;
            }
            
            knockback(fromX, fromY) {
                const dx = this.x - fromX;
                const dy = this.y - fromY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    this.vx = (dx / distance) * TILE;
                    this.vy = (dy / distance) * TILE;
                }
            }
            
            update(dt, player, terrain) {
                const seconds = dt / 1000;
                
                // Sunlight damage for hostiles during day
                if (isDay() && (this.type === 'zombie' || this.type === 'spider')) {
                    const blockAbove = terrain[`${Math.floor(this.x / TILE)},${Math.floor(this.y / TILE) - 1}`];
                    if (!blockAbove || blockAbove === 'air') {
                        return true; // Instant death in sunlight
                    }
                }
                
                // Calculate distance to player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);
                
                // Despawn logic
                if (distanceToPlayer > 45 * TILE) {
                    this.despawnTimer += dt;
                    if (this.despawnTimer > 180000) { // 3 minutes
                        return true;
                    }
                } else {
                    this.despawnTimer = 0;
                }
                
                // AI behavior
                if (this.type === 'sheep') {
                    // Sheep behavior - runs away when attacked
                    if (this.state === 'fleeing') {
                        const angle = Math.atan2(this.y - player.y, this.x - player.x);
                        this.vx = Math.cos(angle) * 3 * TILE * seconds;
                        this.vy = Math.sin(angle) * 3 * TILE * seconds;
                        
                        if (distanceToPlayer > 20 * TILE) {
                            this.state = 'idle';
                        }
                    } else {
                        // Random wandering
                        this.wanderTimer -= dt;
                        if (this.wanderTimer <= 0) {
                            this.targetX = this.x + (Math.random() - 0.5) * 10 * TILE;
                            this.targetY = this.y + (Math.random() - 0.5) * 5 * TILE;
                            this.wanderTimer = 3000 + Math.random() * 5000;
                        }
                        
                        const targetDx = this.targetX - this.x;
                        const targetDy = this.targetY - this.y;
                        const distToTarget = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                        
                        if (distToTarget > TILE) {
                            const angle = Math.atan2(targetDy, targetDx);
                            this.vx = Math.cos(angle) * this.speed * TILE * seconds;
                            this.vy = Math.sin(angle) * this.speed * TILE * seconds;
                        } else {
                            this.vx = 0;
                            this.vy = 0;
                        }
                    }
                } else {
                    // Hostile mobs (zombie, spider)
                    if (distanceToPlayer <= this.chaseRange * TILE) {
                        this.state = 'chasing';
                        
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        this.vx = Math.cos(angle) * this.speed * TILE * seconds;
                        this.vy = Math.sin(angle) * this.speed * TILE * seconds;
                        
                        if (distanceToPlayer <= this.attackRange * TILE) {
                            return 'attack';
                        }
                    } else {
                        this.state = 'idle';
                        // Random movement when not chasing
                        this.wanderTimer -= dt;
                        if (this.wanderTimer <= 0) {
                            this.targetX = this.x + (Math.random() - 0.5) * 5 * TILE;
                            this.targetY = this.y + (Math.random() - 0.5) * 3 * TILE;
                            this.wanderTimer = 2000 + Math.random() * 3000;
                        }
                        
                        const targetDx = this.targetX - this.x;
                        const targetDy = this.targetY - this.y;
                        const distToTarget = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                        
                        if (distToTarget > TILE) {
                            const angle = Math.atan2(targetDy, targetDx);
                            this.vx = Math.cos(angle) * this.speed * TILE * seconds * 0.5;
                            this.vy = Math.sin(angle) * this.speed * TILE * seconds * 0.5;
                        } else {
                            this.vx = 0;
                            this.vy = 0;
                        }
                    }
                }
                
                // Apply gravity
                this.vy += 0.8 * seconds * 60;
                
                // Move horizontally with collision
                this.x += this.vx;
                const mobRect = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
                
                for (const key in terrain) {
                    if (terrain[key] && terrain[key] !== 'air') {
                        const [bx, by] = key.split(',').map(Number);
                        const blockRect = {
                            x: bx * TILE,
                            y: by * TILE,
                            width: TILE,
                            height: TILE
                        };
                        
                        if (rectCollision(mobRect, blockRect)) {
                            if (this.vx > 0) {
                                this.x = blockRect.x - this.width;
                                this.vx = 0;
                            } else if (this.vx < 0) {
                                this.x = blockRect.x + blockRect.width;
                                this.vx = 0;
                            }
                        }
                    }
                }
                
                // Move vertically with collision
                this.y += this.vy;
                mobRect.y = this.y;
                
                this.onGround = false;
                for (const key in terrain) {
                    if (terrain[key] && terrain[key] !== 'air') {
                        const [bx, by] = key.split(',').map(Number);
                        const blockRect = {
                            x: bx * TILE,
                            y: by * TILE,
                            width: TILE,
                            height: TILE
                        };
                        
                        if (rectCollision(mobRect, blockRect)) {
                            if (this.vy > 0) {
                                this.y = blockRect.y - this.height;
                                this.vy = 0;
                                this.onGround = true;
                            } else if (this.vy < 0) {
                                this.y = blockRect.y + blockRect.height;
                                this.vy = 0;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            draw(ctx, camera) {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                // Body
                if (this.type === 'zombie') {
                    ctx.fillStyle = 'rgb(40, 80, 40)';
                    ctx.fillRect(screenX + 6, screenY, 16, 14);
                    
                    // Head
                    ctx.fillStyle = 'rgb(60, 100, 60)';
                    ctx.fillRect(screenX + 8, screenY - 10, 12, 12);
                    
                    // Eyes
                    ctx.fillStyle = 'rgb(255, 0, 0)';
                    ctx.fillRect(screenX + 10, screenY - 6, 3, 3);
                    ctx.fillRect(screenX + 15, screenY - 6, 3, 3);
                    
                } else if (this.type === 'spider') {
                    ctx.fillStyle = 'rgb(150, 0, 0)';
                    ctx.fillRect(screenX + 6, screenY, 16, 14);
                    
                    // Head
                    ctx.fillStyle = 'rgb(180, 0, 0)';
                    ctx.fillRect(screenX + 8, screenY - 10, 12, 12);
                    
                    // Eyes
                    ctx.fillStyle = 'rgb(255, 255, 0)';
                    ctx.fillRect(screenX + 10, screenY - 6, 3, 3);
                    ctx.fillRect(screenX + 15, screenY - 6, 3, 3);
                    
                    // Legs
                    ctx.strokeStyle = 'rgb(100, 0, 0)';
                    ctx.lineWidth = 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(screenX + 6, screenY + 7);
                    ctx.lineTo(screenX, screenY + 14);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(screenX + 22, screenY + 7);
                    ctx.lineTo(screenX + 28, screenY + 14);
                    ctx.stroke();
                    
                } else if (this.type === 'sheep') {
                    ctx.fillStyle = 'rgb(240, 240, 240)';
                    ctx.fillRect(screenX + 6, screenY, 16, 14);
                    
                    // Head
                    ctx.fillStyle = 'rgb(255, 255, 255)';
                    ctx.fillRect(screenX + 8, screenY - 10, 12, 12);
                    
                    // Eyes
                    ctx.fillStyle = 'black';
                    ctx.fillRect(screenX + 10, screenY - 6, 2, 2);
                    ctx.fillRect(screenX + 15, screenY - 6, 2, 2);
                    
                    // Wool texture
                    ctx.fillStyle = 'rgb(220, 220, 220)';
                    for (let i = 0; i < 4; i++) {
                        ctx.fillRect(screenX + 8 + i * 4, screenY + 2, 2, 2);
                    }
                }
                
                // Health bar
                const healthPercent = this.health / this.getMaxHealth();
                ctx.fillStyle = 'red';
                ctx.fillRect(screenX + 4, screenY - 20, 20 * healthPercent, 3);
            }
        }
        
        // ================= MOB SPAWNING =================
        function spawnMobs() {
            const timeInCycle = getTimeOfDay();
            
            // Night spawn - hostiles
            if (timeInCycle >= 600) {
                // Zombie: 1.5% chance per block
                if (Math.random() < 0.015) {
                    const spawnX = Math.floor(player.x / TILE) + Math.floor(Math.random() * 40) - 20;
                    const surfaceY = findSurfaceY(spawnX);
                    if (surfaceY) {
                        mobs.push(new Mob('zombie', spawnX * TILE + TILE/2, (surfaceY - 1) * TILE));
                    }
                }
                
                // Spider: 3% chance per block
                if (Math.random() < 0.03) {
                    const spawnX = Math.floor(player.x / TILE) + Math.floor(Math.random() * 40) - 20;
                    const surfaceY = findSurfaceY(spawnX);
                    if (surfaceY) {
                        mobs.push(new Mob('spider', spawnX * TILE + TILE/2, (surfaceY - 1) * TILE));
                    }
                }
            }
            
            // Day spawn - sheep (4% chance)
            if (timeInCycle < 300) {
                if (Math.random() < 0.04) {
                    const spawnX = Math.floor(player.x / TILE) + Math.floor(Math.random() * 40) - 20;
                    const surfaceY = findSurfaceY(spawnX);
                    if (surfaceY) {
                        mobs.push(new Mob('sheep', spawnX * TILE + TILE/2, (surfaceY - 1) * TILE));
                    }
                }
            }
        }
        
        function findSurfaceY(x) {
            for (let y = 0; y < 100; y++) {
                if (terrain[`${x},${y}`] && terrain[`${x},${y}`] !== 'air') {
                    return y;
                }
            }
            return null;
        }
        
        // ================= BLOCK TEXTURES =================
        let blockTextures = {};
        let blockTextureURLs = {};
        
        // Vegetation types
        const VEGETATION_TYPES = {
            'tall_grass': { chance: 0.3, height: 2 },
            'short_grass': { chance: 0.4, height: 1 },
            'rose': { chance: 0.2, height: 1 },
            'orange_tulip': { chance: 0.1, height: 1 },
            'blue_tulip': { chance: 0.15, height: 1 },
            'lily': { chance: 0.08, height: 1 }
        };
        
        // ================= BREAK TIMES =================
        function getBreakTime(blockType, toolType) {
            if (ORE_TYPES[blockType]) {
                const baseTime = ORE_TYPES[blockType].breakTime;
                if (toolType in PICKAXE_TYPES) {
                    const multiplier = PICKAXE_TYPES[toolType].speedMultiplier;
                    return baseTime / multiplier;
                }
                return baseTime;
            }
            
            if (blockType === 'stone') {
                const baseTime = STONE_BLOCK.stone.breakTime;
                if (toolType in PICKAXE_TYPES) {
                    const multiplier = PICKAXE_TYPES[toolType].speedMultiplier;
                    return baseTime / multiplier;
                }
                return baseTime;
            }
            
            const baseBreakTimes = {
                'grass': 0.6, 'dirt': 0.5, 'wood': 1.4, 'leaves': 0.3, 
                'crafting_table': 1, 'wooden_plank': 0.7, 'stick': 0.2,
                'tall_grass': 1, 'short_grass': 1, 'rose': 1, 'orange_tulip': 1,
                'blue_tulip': 1, 'lily': 1,
                'coal': 0.5, 'iron': 0.8, 'gold': 1, 'diamond': 1.5
            };
            
            return baseBreakTimes[blockType] || 1;
        }
        
        // Get current tool from selected slot
        function getCurrentTool() {
            if (selectedSlot !== null && inventory[selectedSlot]) {
                const item = inventory[selectedSlot].type;
                if (item in PICKAXE_TYPES) {
                    return item;
                }
            }
            return 'hand';
        }
        
        // ================= INITIALIZATION =================
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            
            createBlockTextures();
            setupEventListeners();
            createCraftingGrid();
            loadWorlds();
            resetGame();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Create 3x3 crafting grid UI
        function createCraftingGrid() {
            const grid = document.getElementById('craftingGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'craftingSlot';
                slot.id = `craftInput${i}`;
                slot.addEventListener('click', () => handleCraftInputClick(i));
                grid.appendChild(slot);
            }
        }
        
        // ================= CREATE TEXTURES =================
        function createBlockTextures() {
            // Helper to create a texture
            function createTexture(color1, color2 = null) {
                const canvas = document.createElement('canvas');
                canvas.width = TILE;
                canvas.height = TILE;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
                ctx.fillRect(0, 0, TILE, TILE);
                
                if (color2) {
                    ctx.fillStyle = `rgb(${color2[0]}, ${color2[1]}, ${color2[2]})`;
                    ctx.fillRect(0, 0, TILE, 10);
                }
                
                return canvas;
            }
            
            // Create stone texture with noise
            function createStoneTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = TILE;
                canvas.height = TILE;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = `rgb(${STONE_GRAY[0]}, ${STONE_GRAY[1]}, ${STONE_GRAY[2]})`;
                ctx.fillRect(0, 0, TILE, TILE);
                
                ctx.fillStyle = 'rgb(100, 100, 100)';
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * TILE;
                    const y = Math.random() * TILE;
                    ctx.fillRect(x, y, 2, 2);
                }
                
                return canvas;
            }
            
            // Create ore texture
            function createOreTexture(oreColor, density = 0.3) {
                const canvas = document.createElement('canvas');
                canvas.width = TILE;
                canvas.height = TILE;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = `rgb(${STONE_GRAY[0]}, ${STONE_GRAY[1]}, ${STONE_GRAY[2]})`;
                ctx.fillRect(0, 0, TILE, TILE);
                
                ctx.fillStyle = `rgb(${oreColor[0]}, ${oreColor[1]}, ${oreColor[2]})`;
                const speckleCount = Math.floor(15 * density);
                for (let i = 0; i < speckleCount; i++) {
                    const x = 2 + Math.random() * (TILE - 4);
                    const y = 2 + Math.random() * (TILE - 4);
                    const size = 2 + Math.floor(Math.random() * 3);
                    ctx.fillRect(x, y, size, size);
                }
                
                return canvas;
            }
            
            // Create item texture
            function createItemTexture(color, shape = 'square') {
                const canvas = document.createElement('canvas');
                canvas.width = TILE;
                canvas.height = TILE;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                
                if (shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(TILE/2, TILE/2, TILE/2 - 4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(6, 6, TILE - 12, TILE - 12);
                }
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(10, 10, 5, 5);
                
                return canvas;
            }
            
            // Create pickaxe texture
            function createPickaxeTexture(material) {
                const canvas = document.createElement('canvas');
                canvas.width = TILE;
                canvas.height = TILE;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, TILE, TILE);
                
                ctx.fillStyle = 'rgb(139, 69, 19)';
                ctx.fillRect(14, 8, 4, 20);
                
                let headColor;
                switch(material) {
                    case 'stone': headColor = [100, 100, 100]; break;
                    case 'iron': headColor = [180, 180, 180]; break;
                    case 'gold': headColor = [255, 215, 0]; break;
                    case 'diamond': headColor = [0, 255, 255]; break;
                }
                
                ctx.fillStyle = `rgb(${headColor[0]}, ${headColor[1]}, ${headColor[2]})`;
                ctx.fillRect(6, 6, 12, 8);
                ctx.fillRect(18, 10, 4, 6);
                
                return canvas;
            }
            
            // Stick texture
            function createStickTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = TILE;
                canvas.height = TILE;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = 'rgb(139, 69, 19)';
                ctx.fillRect(0, 0, TILE, TILE);
                
                ctx.strokeStyle = 'rgb(255, 228, 181)';
                ctx.lineWidth = 4;
                
                ctx.beginPath();
                ctx.moveTo(6, 8);
                ctx.lineTo(26, 24);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(6, 24);
                ctx.lineTo(26, 8);
                ctx.stroke();
                
                return canvas;
            }
            
            // Grass texture
            function createGrassTexture(type, height = 1) {
                const canvas = document.createElement('canvas');
                const canvasHeight = TILE * height;
                canvas.width = TILE;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, TILE, canvasHeight);
                
                ctx.strokeStyle = type === 'tall_grass' ? 
                    `rgb(${TALL_GRASS_GREEN[0]}, ${TALL_GRASS_GREEN[1]}, ${TALL_GRASS_GREEN[2]})` :
                    `rgb(${GRASS_GREEN[0]}, ${GRASS_GREEN[1]}, ${GRASS_GREEN[2]})`;
                
                ctx.lineWidth = 2;
                const bladeCount = type === 'tall_grass' ? 9 : 7;
                const bladeHeight = type === 'tall_grass' ? TILE * 1.5 : TILE * 0.8;
                
                for (let i = 0; i < bladeCount; i++) {
                    const x = 2 + i * 3;
                    const curve = Math.sin(i * 0.8) * 4;
                    const bladeTop = canvasHeight - bladeHeight + Math.random() * 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, canvasHeight);
                    ctx.quadraticCurveTo(x + curve, canvasHeight - bladeHeight/2, x, bladeTop);
                    ctx.stroke();
                }
                
                return canvas;
            }
            
            // Flower textures
            function createFlowerTexture(type) {
                const canvas = document.createElement('canvas');
                canvas.width = TILE;
                canvas.height = TILE;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, TILE, TILE);
                
                ctx.fillStyle = `rgb(${STEM_GREEN[0]}, ${STEM_GREEN[1]}, ${STEM_GREEN[2]})`;
                ctx.fillRect(TILE/2 - 1, TILE - 12, 2, 12);
                
                ctx.fillStyle = `rgb(${STEM_GREEN[0]}, ${STEM_GREEN[1]}, ${STEM_GREEN[2]})`;
                ctx.beginPath();
                ctx.ellipse(TILE/2 + 4, TILE - 8, 4, 2, Math.PI/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(TILE/2 - 4, TILE - 6, 4, 2, -Math.PI/4, 0, Math.PI * 2);
                ctx.fill();
                
                if (type === 'rose') {
                    ctx.fillStyle = 'rgb(255, 0, 0)';
                    ctx.beginPath();
                    ctx.arc(TILE/2, TILE - 18, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgb(255, 200, 0)';
                    ctx.beginPath();
                    ctx.arc(TILE/2, TILE - 18, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (type === 'orange_tulip') {
                    ctx.fillStyle = 'rgb(255, 165, 0)';
                    ctx.beginPath();
                    ctx.arc(TILE/2, TILE - 18, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (type === 'blue_tulip') {
                    ctx.fillStyle = 'rgb(0, 100, 255)';
                    ctx.beginPath();
                    ctx.arc(TILE/2, TILE - 18, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (type === 'lily') {
                    ctx.fillStyle = 'rgb(255, 255, 255)';
                    ctx.beginPath();
                    ctx.arc(TILE/2, TILE - 18, 7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgb(255, 255, 0)';
                    ctx.beginPath();
                    ctx.arc(TILE/2, TILE - 18, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return canvas;
            }
            
            // Create all textures
            const textures = {
                'grass': createTexture(BROWN, GREEN),
                'dirt': createTexture(BROWN),
                'wood': createTexture([139, 69, 19]),
                'leaves': createTexture([34, 139, 34]),
                'stone': createStoneTexture(),
                'air': createTexture([0, 0, 0]),
                'crafting_table': createTexture([160, 82, 45]),
                'wooden_plank': createTexture([205, 133, 63]),
                'stick': createStickTexture(),
                
                'coal_ore': createOreTexture(COAL_BLACK, 0.5),
                'iron_ore': createOreTexture(IRON_GRAY, 0.4),
                'gold_ore': createOreTexture(GOLD_YELLOW, 0.3),
                'diamond_ore': createOreTexture(DIAMOND_CYAN, 0.2),
                
                'coal': createItemTexture(COAL_BLACK),
                'iron': createItemTexture(IRON_GRAY),
                'gold': createItemTexture(GOLD_YELLOW),
                'diamond': createItemTexture(DIAMOND_CYAN, 'circle'),
                
                'stone_pickaxe': createPickaxeTexture('stone'),
                'iron_pickaxe': createPickaxeTexture('iron'),
                'gold_pickaxe': createPickaxeTexture('gold'),
                'diamond_pickaxe': createPickaxeTexture('diamond'),
                
                'tall_grass': createGrassTexture('tall_grass', 2),
                'short_grass': createGrassTexture('short_grass', 1),
                'rose': createFlowerTexture('rose'),
                'orange_tulip': createFlowerTexture('orange_tulip'),
                'blue_tulip': createFlowerTexture('blue_tulip'),
                'lily': createFlowerTexture('lily')
            };
            
            blockTextures = textures;
            for (const [key, textureCanvas] of Object.entries(textures)) {
                blockTextureURLs[key] = textureCanvas.toDataURL();
            }
        }
        
        // ================= SETUP EVENT LISTENERS =================
        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd);
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            document.getElementById('leftBtn').addEventListener('mousedown', () => setKeyState('left', true));
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                setKeyState('left', true);
            });
            document.getElementById('leftBtn').addEventListener('mouseup', () => setKeyState('left', false));
            document.getElementById('leftBtn').addEventListener('mouseleave', () => setKeyState('left', false));
            document.getElementById('leftBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                setKeyState('left', false);
            });
            
            document.getElementById('rightBtn').addEventListener('mousedown', () => setKeyState('right', true));
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                setKeyState('right', true);
            });
            document.getElementById('rightBtn').addEventListener('mouseup', () => setKeyState('right', false));
            document.getElementById('rightBtn').addEventListener('mouseleave', () => setKeyState('right', false));
            document.getElementById('rightBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                setKeyState('right', false);
            });
            
            document.getElementById('jumpBtn').addEventListener('mousedown', () => setKeyState('jump', true));
            document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                setKeyState('jump', true);
            });
            document.getElementById('jumpBtn').addEventListener('mouseup', () => setKeyState('jump', false));
            document.getElementById('jumpBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                setKeyState('jump', false);
            });
            
            document.getElementById('newWorldBtn').addEventListener('click', () => {
                resetGame();
                const worldId = createNewWorld();
                loadWorld(worldId);
                startGame();
            });
            
            document.getElementById('saveButton').addEventListener('click', () => {
                saveCurrentWorld();
            });
            
            document.getElementById('restartBtn').addEventListener('click', () => {
                resetGame();
                gameState = 'PLAYING';
                document.getElementById('gameOverScreen').classList.add('hidden');
                dayStartTime = Date.now() / 1000;
                updateInventoryUI();
            });
            
            document.getElementById('craftingClose').addEventListener('click', closeCrafting);
            document.getElementById('craftingOutput').addEventListener('click', takeCraftingOutput);
            
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            document.body.addEventListener('touchmove', (e) => {
                if (gameState === 'PLAYING') {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        let keys = {
            left: false,
            right: false,
            jump: false
        };
        
        function setKeyState(key, state) {
            keys[key] = state;
        }
        
        function handleKeyDown(e) {
            if (gameState !== 'PLAYING') return;
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === ' ') {
                keys.jump = true;
                e.preventDefault();
            }
        }
        
        function handleKeyUp(e) {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === ' ') keys.jump = false;
        }
        
        // ================= MOUSE HANDLING =================
        function handleMouseDown(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            mouse.down = true;
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            
            handleGameClick(mouse.x, mouse.y);
        }
        
        function handleMouseMove(e) {
            if (gameState !== 'PLAYING') return;
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        }
        
        function handleMouseUp() {
            mouse.down = false;
        }
        
        function handleTouchStart(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            mouse.down = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouse.x = touch.clientX - rect.left;
            mouse.y = touch.clientY - rect.top;
            
            handleGameClick(mouse.x, mouse.y);
        }
        
        function handleTouchMove(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouse.x = touch.clientX - rect.left;
            mouse.y = touch.clientY - rect.top;
        }
        
        function handleTouchEnd() {
            mouse.down = false;
        }
        
        function handleGameClick(x, y) {
            if (craftingActive) return;
            
            const inventoryContainer = document.getElementById('inventoryContainer');
            const containerRect = inventoryContainer.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            const containerX = containerRect.left - canvasRect.left;
            const containerY = containerRect.top - canvasRect.top;
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;
            
            if (x >= containerX && x <= containerX + containerWidth &&
                y >= containerY && y <= containerY + containerHeight) {
                return;
            }
            
            // Check for mob attack first
            if (attackCooldown <= 0) {
                const worldX = x + camera.x;
                const worldY = y + camera.y;
                
                for (let i = mobs.length - 1; i >= 0; i--) {
                    const mob = mobs[i];
                    const dx = worldX - mob.x;
                    const dy = worldY - mob.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= 4 * TILE) {
                        if (mob.takeDamage(0.5)) {
                            mobs.splice(i, 1);
                        } else {
                            mob.knockback(player.x, player.y);
                            if (mob.type === 'sheep') {
                                mob.state = 'fleeing';
                            }
                        }
                        attackCooldown = 500;
                        return;
                    }
                }
            }
            
            const worldX = x + camera.x;
            const worldY = y + camera.y;
            const blockX = Math.floor(worldX / TILE);
            const blockY = Math.floor(worldY / TILE);
            
            const vegKey = `${blockX},${blockY}`;
            if (vegetation[vegKey]) {
                breaking = {x: blockX, y: blockY};
                breakingType = 'vegetation';
                breakStartTime = Date.now() / 1000;
                return;
            }
            
            const blockKey = `${blockX},${blockY}`;
            if (terrain[blockKey] && terrain[blockKey] !== 'air') {
                breaking = {x: blockX, y: blockY};
                breakingType = 'terrain';
                breakStartTime = Date.now() / 1000;
            } else {
                if (selectedSlot !== null && inventory[selectedSlot]) {
                    const itemType = inventory[selectedSlot].type;
                    
                    if (itemType in VEGETATION_TYPES) {
                        const blockBelowKey = `${blockX},${blockY+1}`;
                        const blockBelow = terrain[blockBelowKey];
                        
                        if ((blockBelow === 'grass' || blockBelow === 'dirt') && 
                            !vegetation[vegKey] && !terrain[blockKey]) {
                            vegetation[vegKey] = itemType;
                            removeFromInventory(selectedSlot, 1);
                        }
                    } else {
                        const adjacent = [
                            `${blockX+1},${blockY}`,
                            `${blockX-1},${blockY}`,
                            `${blockX},${blockY+1}`,
                            `${blockX},${blockY-1}`
                        ];
                        
                        let canPlace = false;
                        for (const key of adjacent) {
                            if (terrain[key] || vegetation[key]) {
                                canPlace = true;
                                break;
                            }
                        }
                        
                        const playerBlockX = Math.floor(player.x / TILE);
                        const playerBlockY = Math.floor((player.y + player.height) / TILE);
                        const notInsidePlayer = !(blockX === playerBlockX && blockY === playerBlockY);
                        
                        if (canPlace && notInsidePlayer && !vegetation[vegKey]) {
                            terrain[blockKey] = itemType;
                            removeFromInventory(selectedSlot, 1);
                        }
                    }
                }
            }
        }
        
        function handleInventoryClick(index) {
            if (inventory[index]) {
                if (inventory[index].type === 'crafting_table') {
                    openCrafting();
                    return;
                }
                
                if (selectedSlot === index) {
                    selectedSlot = null;
                } else {
                    selectedSlot = index;
                }
                updateInventoryUI();
            } else {
                selectedSlot = null;
                updateInventoryUI();
            }
        }
        
        // ================= PLAYER =================
        function createPlayer() {
            return {
                x: WIDTH / 2,
                y: HEIGHT / 2,
                width: 28,
                height: 44,
                vx: 0,
                vy: 0,
                onGround: false,
                prevY: HEIGHT / 2,
                velocityX: 0
            };
        }
        
        function updatePlayer() {
            let targetVelX = 0;
            if (keys.left) targetVelX = -4;
            if (keys.right) targetVelX = 4;
            
            player.velocityX += (targetVelX - player.velocityX) * 0.5;
            player.x += player.velocityX;
            
            const playerRect = {
                x: player.x,
                y: player.y,
                width: player.width,
                height: player.height
            };
            
            for (const key in terrain) {
                if (terrain[key] && terrain[key] !== 'air') {
                    const [bx, by] = key.split(',').map(Number);
                    const blockRect = {
                        x: bx * TILE,
                        y: by * TILE,
                        width: TILE,
                        height: TILE
                    };
                    
                    if (rectCollision(playerRect, blockRect)) {
                        if (player.velocityX > 0) {
                            player.x = blockRect.x - player.width;
                            player.velocityX = 0;
                        } else if (player.velocityX < 0) {
                            player.x = blockRect.x + blockRect.width;
                            player.velocityX = 0;
                        }
                    }
                }
            }
            
            player.vy += 0.8;
            player.y += player.vy;
            
            player.onGround = false;
            let landed = false;
            
            playerRect.y = player.y;
            for (const key in terrain) {
                if (terrain[key] && terrain[key] !== 'air') {
                    const [bx, by] = key.split(',').map(Number);
                    const blockRect = {
                        x: bx * TILE,
                        y: by * TILE,
                        width: TILE,
                        height: TILE
                    };
                    
                    if (rectCollision(playerRect, blockRect)) {
                        if (player.vy > 0) {
                            player.y = blockRect.y - player.height;
                            player.vy = 0;
                            player.onGround = true;
                            landed = true;
                        } else if (player.vy < 0) {
                            player.y = blockRect.y + blockRect.height;
                            player.vy = 0;
                        }
                    }
                }
            }
            
            if (keys.jump && player.onGround) {
                player.vy = -13;
                keys.jump = false;
            }
            
            if (landed) {
                const fallDistance = Math.floor((player.prevY - player.y) / TILE);
                const damage = damageTable[fallDistance] || 0;
                
                if (damage > 0) {
                    health -= damage;
                    if (health <= 0) {
                        health = 0;
                        gameOver = true;
                        gameState = 'GAME_OVER';
                        document.getElementById('gameOverScreen').classList.remove('hidden');
                    }
                    updateHealthUI();
                }
            }
            
            if (player.onGround) {
                player.prevY = player.y;
            }
            
            camera.x += (player.x - camera.x - WIDTH/2) * 0.1;
            camera.y += (player.y - camera.y - HEIGHT/2) * 0.1;
        }
        
        function drawPlayer() {
            ctx.fillStyle = 'rgb(240, 200, 170)';
            ctx.fillRect(player.x - camera.x + 6, player.y - camera.y, 16, 14);
            
            ctx.fillStyle = 'rgb(30, 144, 255)';
            ctx.fillRect(player.x - camera.x + 4, player.y - camera.y + 14, 20, 14);
            
            ctx.fillStyle = 'rgb(20, 20, 120)';
            ctx.fillRect(player.x - camera.x + 6, player.y - camera.y + 28, 6, 14);
            ctx.fillRect(player.x - camera.x + 16, player.y - camera.y + 28, 6, 14);
        }
        
        // ================= TERRAIN GENERATION =================
        function generateTerrainAt(x) {
            let h = heights[x-1] !== undefined ? heights[x-1] : 20;
            h += Math.random() < 0.5 ? -1 : 1;
            h = Math.max(15, Math.min(35, h));
            heights[x] = h;
            
            for (let i = 0; i < 60; i++) { // Generate deeper for caves
                const y = h + i;
                const key = `${x},${y}`;
                
                if (i === 0) {
                    terrain[key] = 'grass';
                    
                    const vegY = h - 1;
                    const vegKey = `${x},${vegY}`;
                    
                    if (Math.random() < 0.7) {
                        let vegGenerated = false;
                        
                        for (const [vegType, vegData] of Object.entries(VEGETATION_TYPES)) {
                            if (!vegGenerated && Math.random() < vegData.chance) {
                                const hasFlower = Object.keys(vegetation).some(k => {
                                    const [vx, vy] = k.split(',').map(Number);
                                    return vx === x && vy === vegY;
                                });
                                
                                if (!hasFlower) {
                                    vegetation[vegKey] = vegType;
                                    vegGenerated = true;
                                }
                            }
                        }
                    }
                } else if (i >= 1 && i <= 4) {
                    terrain[key] = 'dirt';
                } else if (i >= 5) {
                    let blockType = 'stone';
                    
                    const depth = i;
                    
                    if (depth >= 10 && depth <= 35 && Math.random() < 0.5) {
                        blockType = 'coal_ore';
                    } else if (depth >= 15 && depth <= 40 && Math.random() < 0.3) {
                        blockType = 'iron_ore';
                    } else if (depth >= 20 && depth <= 45 && Math.random() < 0.15) {
                        blockType = 'gold_ore';
                    } else if (depth >= 30 && depth <= 60 && Math.random() < 0.05) {
                        blockType = 'diamond_ore';
                    }
                    
                    terrain[key] = blockType;
                    
                    // Generate caves at depth >= 30
                    if (depth >= 30) {
                        generateCaveAt(x, y);
                    }
                }
            }
            
            if (Math.random() < 0.1) {
                for (let i = 1; i < 4; i++) {
                    terrain[`${x},${h-i}`] = 'wood';
                }
                
                const leavesPositions = [
                    [-1, -4], [0, -4], [1, -4], [0, -5]
                ];
                
                for (const [dx, dy] of leavesPositions) {
                    terrain[`${x+dx},${h+dy}`] = 'leaves';
                }
            }
        }
        
        function drawTerrain() {
            for (const key in terrain) {
                if (!terrain[key] || terrain[key] === 'air') continue;
                
                const [x, y] = key.split(',').map(Number);
                const blockType = terrain[key];
                
                const screenX = x * TILE - camera.x;
                const screenY = y * TILE - camera.y;
                
                if (screenX > -TILE && screenX < WIDTH && screenY > -TILE && screenY < HEIGHT) {
                    ctx.drawImage(blockTextures[blockType], screenX, screenY);
                }
            }
            
            for (const key in vegetation) {
                const [x, y] = key.split(',').map(Number);
                const vegType = vegetation[key];
                const vegData = VEGETATION_TYPES[vegType];
                
                const screenX = x * TILE - camera.x;
                const screenY = y * TILE - camera.y;
                
                if (screenX > -TILE && screenX < WIDTH && 
                    screenY > -TILE * vegData.height && screenY < HEIGHT) {
                    ctx.drawImage(blockTextures[vegType], screenX, screenY);
                }
            }
            
            if (breaking) {
                const currentTime = Date.now() / 1000;
                const breakDuration = currentTime - breakStartTime;
                
                let blockType;
                if (breakingType === 'vegetation') {
                    const vegKey = `${breaking.x},${breaking.y}`;
                    blockType = vegetation[vegKey];
                } else {
                    const blockKey = `${breaking.x},${breaking.y}`;
                    blockType = terrain[blockKey];
                }
                
                if (blockType && blockType !== 'air') {
                    const toolType = getCurrentTool();
                    const breakTime = getBreakTime(blockType, toolType);
                    const progress = breakDuration / breakTime;
                    
                    if (progress >= 1) {
                        let shouldDrop = true;
                        let dropType = blockType;
                        
                        if (ORE_TYPES[blockType]) {
                            if (toolType === 'hand' || !(toolType in PICKAXE_TYPES)) {
                                shouldDrop = false;
                            } else {
                                dropType = ORE_TYPES[blockType].drop;
                            }
                        } else if (blockType === 'stone') {
                            dropType = 'stone';
                        }
                        
                        if (shouldDrop) {
                            const dropX = breaking.x * TILE + TILE/2;
                            const dropY = breaking.y * TILE + TILE/2;
                            
                            drops.push({
                                x: dropX,
                                y: dropY,
                                type: dropType,
                                vy: -5
                            });
                        }
                        
                        if (breakingType === 'vegetation') {
                            delete vegetation[`${breaking.x},${breaking.y}`];
                        } else {
                            delete terrain[`${breaking.x},${breaking.y}`];
                        }
                        
                        breaking = null;
                        breakingType = null;
                    } else {
                        let screenX, screenY;
                        if (breakingType === 'vegetation') {
                            screenX = breaking.x * TILE - camera.x;
                            screenY = breaking.y * TILE - camera.y;
                        } else {
                            screenX = breaking.x * TILE - camera.x;
                            screenY = breaking.y * TILE - camera.y;
                        }
                        
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        const segment = Math.floor(progress * 10);
                        
                        for (let i = 0; i < segment; i++) {
                            const x1 = screenX + Math.random() * TILE;
                            const y1 = screenY + Math.random() * TILE;
                            const x2 = x1 + (Math.random() - 0.5) * 20;
                            const y2 = y1 + (Math.random() - 0.5) * 20;
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                } else {
                    breaking = null;
                    breakingType = null;
                }
            }
        }
        
        // ================= DROPS =================
        function updateDrops() {
            for (let i = drops.length - 1; i >= 0; i--) {
                const drop = drops[i];
                
                drop.vy += 0.5;
                drop.y += drop.vy;
                
                const dropRect = {
                    x: drop.x - 8,
                    y: drop.y - 8,
                    width: 16,
                    height: 16
                };
                
                for (const key in terrain) {
                    if (terrain[key] && terrain[key] !== 'air') {
                        const [bx, by] = key.split(',').map(Number);
                        const blockRect = {
                            x: bx * TILE,
                            y: by * TILE,
                            width: TILE,
                            height: TILE
                        };
                        
                        if (rectCollision(dropRect, blockRect) && drop.vy > 0) {
                            drop.y = blockRect.y - 8;
                            drop.vy = 0;
                        }
                    }
                }
                
                const playerRect = {
                    x: player.x,
                    y: player.y,
                    width: player.width,
                    height: player.height
                };
                
                if (rectCollision(dropRect, playerRect)) {
                    if (addToInventory(drop.type, 1)) {
                        drops.splice(i, 1);
                    }
                }
            }
        }
        
        function drawDrops() {
            for (const drop of drops) {
                const screenX = drop.x - camera.x - 8;
                const screenY = drop.y - camera.y - 8;
                
                ctx.drawImage(blockTextures[drop.type], screenX, screenY, 16, 16);
            }
        }
        
        // ================= INVENTORY =================
        function initInventory() {
            inventory = [
                {type: 'crafting_table', count: 1},
                null, null, null, null, null, null, null, null
            ];
            selectedSlot = 0;
            updateInventoryUI();
        }
        
        function addToInventory(itemType, count) {
            for (let i = 0; i < inventory.length; i++) {
                if (inventory[i] && inventory[i].type === itemType && inventory[i].count < 200) {
                    const space = 200 - inventory[i].count;
                    const toAdd = Math.min(space, count);
                    
                    inventory[i].count += toAdd;
                    count -= toAdd;
                    
                    if (count === 0) {
                        updateInventoryUI();
                        return true;
                    }
                }
            }
            
            for (let i = 0; i < inventory.length; i++) {
                if (!inventory[i]) {
                    inventory[i] = {type: itemType, count: Math.min(count, 200)};
                    count -= Math.min(count, 200);
                    
                    if (count === 0) {
                        updateInventoryUI();
                        return true;
                    }
                }
            }
            
            updateInventoryUI();
            return false;
        }
        
        function removeFromInventory(index, amount) {
            if (!inventory[index]) return;
            
            inventory[index].count -= amount;
            if (inventory[index].count <= 0) {
                inventory[index] = null;
                
                if (selectedSlot === index) {
                    selectedSlot = null;
                }
            }
            
            updateInventoryUI();
        }
        
        function updateInventoryUI() {
            const inventoryEl = document.getElementById('inventory');
            inventoryEl.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventorySlot';
                if (i === selectedSlot) {
                    slot.classList.add('selectedSlot');
                }
                
                if (inventory[i]) {
                    const img = document.createElement('img');
                    img.src = blockTextureURLs[inventory[i].type];
                    img.className = 'blockPreview';
                    slot.appendChild(img);
                    
                    if (inventory[i].count > 1) {
                        const count = document.createElement('div');
                        count.className = 'itemCount';
                        count.textContent = inventory[i].count;
                        slot.appendChild(count);
                    }
                }
                
                slot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleInventoryClick(i);
                });
                inventoryEl.appendChild(slot);
            }
        }
        
        // ================= CRAFTING =================
        const recipes = [
            {
                name: 'wood',
                pattern: (inputs) => {
                    const items = inputs.filter(i => i !== null);
                    return items.length === 1 && items[0] === 'wood';
                },
                result: 'wooden_plank',
                count: 4
            },
            {
                name: 'sticks',
                pattern: (inputs) => {
                    const verticalPairs = [
                        [0, 3], [1, 4], [2, 5], [3, 6], [4, 7], [5, 8]
                    ];
                    
                    for (const [top, bottom] of verticalPairs) {
                        if (inputs[top] === 'wooden_plank' && inputs[bottom] === 'wooden_plank') {
                            let otherEmpty = true;
                            for (let i = 0; i < 9; i++) {
                                if (i !== top && i !== bottom && inputs[i] !== null) {
                                    otherEmpty = false;
                                    break;
                                }
                            }
                            if (otherEmpty) return true;
                        }
                    }
                    return false;
                },
                result: 'stick',
                count: 2
            },
            {
                name: 'tall_grass',
                pattern: (inputs) => {
                    const items = inputs.filter(i => i !== null);
                    return items.length === 1 && items[0] === 'tall_grass';
                },
                result: 'short_grass',
                count: 2
            },
            {
                name: 'stone_pickaxe',
                pattern: (inputs) => {
                    return inputs[0] === 'stone' && inputs[1] === 'stone' && inputs[2] === 'stone' &&
                           inputs[4] === 'stick' && inputs[7] === 'stick' &&
                           inputs[3] === null && inputs[5] === null && inputs[6] === null && inputs[8] === null;
                },
                result: 'stone_pickaxe',
                count: 1
            },
            {
                name: 'iron_pickaxe',
                pattern: (inputs) => {
                    return inputs[0] === 'iron' && inputs[1] === 'iron' && inputs[2] === 'iron' &&
                           inputs[4] === 'stick' && inputs[7] === 'stick' &&
                           inputs[3] === null && inputs[5] === null && inputs[6] === null && inputs[8] === null;
                },
                result: 'iron_pickaxe',
                count: 1
            },
            {
                name: 'gold_pickaxe',
                pattern: (inputs) => {
                    return inputs[0] === 'gold' && inputs[1] === 'gold' && inputs[2] === 'gold' &&
                           inputs[4] === 'stick' && inputs[7] === 'stick' &&
                           inputs[3] === null && inputs[5] === null && inputs[6] === null && inputs[8] === null;
                },
                result: 'gold_pickaxe',
                count: 1
            },
            {
                name: 'diamond_pickaxe',
                pattern: (inputs) => {
                    return inputs[0] === 'diamond' && inputs[1] === 'diamond' && inputs[2] === 'diamond' &&
                           inputs[4] === 'stick' && inputs[7] === 'stick' &&
                           inputs[3] === null && inputs[5] === null && inputs[6] === null && inputs[8] === null;
                },
                result: 'diamond_pickaxe',
                count: 1
            }
        ];
        
        function openCrafting() {
            craftingActive = true;
            document.getElementById('craftingUI').classList.remove('hidden');
            updateCraftingUI();
        }
        
        function closeCrafting() {
            craftingActive = false;
            document.getElementById('craftingUI').classList.add('hidden');
            
            for (let i = 0; i < 9; i++) {
                if (craftingInputs[i]) {
                    addToInventory(craftingInputs[i], 1);
                    craftingInputs[i] = null;
                }
            }
            craftingOutput = null;
            updateCraftingUI();
        }
        
        function handleCraftInputClick(index) {
            if (selectedSlot !== null && inventory[selectedSlot]) {
                craftingInputs[index] = inventory[selectedSlot].type;
                removeFromInventory(selectedSlot, 1);
                updateCraftingUI();
                checkRecipes();
            } else if (craftingInputs[index] !== null) {
                addToInventory(craftingInputs[index], 1);
                craftingInputs[index] = null;
                updateCraftingUI();
                checkRecipes();
            }
        }
        
        function checkRecipes() {
            for (const recipe of recipes) {
                if (recipe.pattern(craftingInputs)) {
                    craftingOutput = {
                        type: recipe.result,
                        count: recipe.count
                    };
                    updateCraftingUI();
                    return;
                }
            }
            
            craftingOutput = null;
            updateCraftingUI();
        }
        
        function takeCraftingOutput() {
            if (craftingOutput && addToInventory(craftingOutput.type, craftingOutput.count)) {
                for (let i = 0; i < 9; i++) {
                    craftingInputs[i] = null;
                }
                craftingOutput = null;
                updateCraftingUI();
            }
        }
        
        function updateCraftingUI() {
            for (let i = 0; i < 9; i++) {
                const slot = document.getElementById(`craftInput${i}`);
                slot.innerHTML = '';
                
                if (craftingInputs[i]) {
                    const img = document.createElement('img');
                    img.src = blockTextureURLs[craftingInputs[i]];
                    img.className = 'blockPreview';
                    slot.appendChild(img);
                }
            }
            
            const outputSlot = document.getElementById('craftingOutput');
            outputSlot.innerHTML = '';
            
            if (craftingOutput) {
                const img = document.createElement('img');
                img.src = blockTextureURLs[craftingOutput.type];
                img.className = 'blockPreview';
                outputSlot.appendChild(img);
                
                if (craftingOutput.count > 1) {
                    const count = document.createElement('div');
                    count.className = 'itemCount';
                    count.textContent = craftingOutput.count;
                    outputSlot.appendChild(count);
                }
            }
        }
        
        // ================= HEALTH UI =================
        function updateHealthUI() {
            const healthBar = document.getElementById('healthBar');
            healthBar.innerHTML = '';
            
            const fullHearts = Math.floor(health);
            const hasPartial = health % 1 > 0;
            
            for (let i = 0; i < 10; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                
                if (i < fullHearts) {
                    heart.style.backgroundColor = 'red';
                    heart.style.width = '30px';
                } else if (i === fullHearts && hasPartial) {
                    heart.style.backgroundColor = 'red';
                    heart.style.width = '15px';
                } else {
                    heart.style.backgroundColor = 'gray';
                    heart.style.width = '30px';
                }
                
                healthBar.appendChild(heart);
            }
        }
        
        // ================= SKY =================
        function drawSky() {
            const skyColor = getSkyColor();
            ctx.fillStyle = `rgb(${skyColor[0]}, ${skyColor[1]}, ${skyColor[2]})`;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            const timeInCycle = getTimeOfDay();
            
            // Draw sun or moon
            if (timeInCycle < 600) {
                // Sun during day and sunset
                ctx.fillStyle = 'rgb(255, 255, 100)';
                ctx.beginPath();
                ctx.arc(WIDTH - 100, 100, 30, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Moon at night
                ctx.fillStyle = 'rgb(200, 200, 200)';
                ctx.beginPath();
                ctx.arc(WIDTH - 100, 100, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ================= GAME STATE MANAGEMENT =================
        function startGame() {
            gameState = 'PLAYING';
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameOverlay').classList.remove('hidden');
            document.getElementById('inventoryContainer').classList.remove('hidden');
            document.getElementById('mobileControls').classList.remove('hidden');
            dayStartTime = Date.now() / 1000;
            updateInventoryUI();
        }
        
        function resetGame() {
            player = createPlayer();
            terrain = {};
            vegetation = {};
            heights = {};
            drops = [];
            mobs = [];
            craftingInputs = [
                null, null, null,
                null, null, null,
                null, null, null
            ];
            craftingOutput = null;
            breaking = null;
            breakingType = null;
            health = 10;
            gameOver = false;
            camera = {x: 0, y: 0};
            
            initInventory();
            updateHealthUI();
            
            const startX = Math.floor(player.x / TILE);
            for (let x = startX - 15; x < startX + 15; x++) {
                generateTerrainAt(x);
            }
        }
        
        function rectCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // ================= GAME LOOP =================
        let lastTime = 0;
        
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (deltaTime > 1000/60) {
                updateGame(deltaTime);
                drawGame();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateGame(deltaTime) {
            if (gameState !== 'PLAYING') return;
            
            attackCooldown = Math.max(0, attackCooldown - deltaTime);
            
            gameTime += deltaTime / 1000;
            updateTimeDisplay();
            
            const playerTileX = Math.floor(player.x / TILE);
            for (let x = playerTileX - 15; x < playerTileX + 15; x++) {
                if (heights[x] === undefined) {
                    generateTerrainAt(x);
                }
            }
            
            // Spawn mobs
            spawnMobs();
            
            // Update mobs
            for (let i = mobs.length - 1; i >= 0; i--) {
                const result = mobs[i].update(deltaTime, player, terrain);
                
                if (result === true) {
                    mobs.splice(i, 1);
                } else if (result === 'attack') {
                    health -= mobs[i].attackDamage;
                    if (health <= 0) {
                        health = 0;
                        gameOver = true;
                        gameState = 'GAME_OVER';
                        document.getElementById('gameOverScreen').classList.remove('hidden');
                    }
                    updateHealthUI();
                    
                    const dx = player.x - mobs[i].x;
                    const dy = player.y - mobs[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        player.x += (dx / distance) * TILE;
                        player.y += (dy / distance) * TILE;
                    }
                }
            }
            
            updatePlayer();
            updateDrops();
            
            if (mouse.down && breaking) {
                const currentTime = Date.now() / 1000;
                const breakDuration = currentTime - breakStartTime;
                
                let blockType;
                if (breakingType === 'vegetation') {
                    const vegKey = `${breaking.x},${breaking.y}`;
                    blockType = vegetation[vegKey];
                } else {
                    const blockKey = `${breaking.x},${breaking.y}`;
                    blockType = terrain[blockKey];
                }
                
                if (blockType && blockType !== 'air') {
                    const toolType = getCurrentTool();
                    const breakTime = getBreakTime(blockType, toolType);
                    
                    if (breakDuration >= breakTime) {
                        let shouldDrop = true;
                        let dropType = blockType;
                        
                        if (ORE_TYPES[blockType]) {
                            if (toolType === 'hand' || !(toolType in PICKAXE_TYPES)) {
                                shouldDrop = false;
                            } else {
                                dropType = ORE_TYPES[blockType].drop;
                            }
                        } else if (blockType === 'stone') {
                            dropType = 'stone';
                        }
                        
                        if (shouldDrop) {
                            const dropX = breaking.x * TILE + TILE/2;
                            const dropY = breaking.y * TILE + TILE/2;
                            
                            drops.push({
                                x: dropX,
                                y: dropY,
                                type: dropType,
                                vy: -5
                            });
                        }
                        
                        if (breakingType === 'vegetation') {
                            delete vegetation[`${breaking.x},${breaking.y}`];
                        } else {
                            delete terrain[`${breaking.x},${breaking.y}`];
                        }
                        
                        breaking = null;
                        breakingType = null;
                    }
                } else {
                    breaking = null;
                    breakingType = null;
                }
            }
        }
        
        function drawGame() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            if (gameState === 'PLAYING') {
                drawSky();
                drawTerrain();
                drawDrops();
                
                for (const mob of mobs) {
                    mob.draw(ctx, camera);
                }
                
                drawPlayer();
                
                if (selectedSlot !== null && inventory[selectedSlot] && !craftingActive) {
                    const worldX = mouse.x + camera.x;
                    const worldY = mouse.y + camera.y;
                    const blockX = Math.floor(worldX / TILE);
                    const blockY = Math.floor(worldY / TILE);
                    
                    const blockKey = `${blockX},${blockY}`;
                    const vegKey = `${blockX},${blockY}`;
                    
                    if (!terrain[blockKey] && !vegetation[vegKey]) {
                        const itemType = inventory[selectedSlot].type;
                        
                        if (itemType in VEGETATION_TYPES) {
                            const blockBelowKey = `${blockX},${blockY+1}`;
                            const blockBelow = terrain[blockBelowKey];
                            
                            if (blockBelow === 'grass' || blockBelow === 'dirt') {
                                const screenX = blockX * TILE - camera.x;
                                const screenY = blockY * TILE - camera.y;
                                
                                ctx.globalAlpha = 0.6;
                                ctx.drawImage(blockTextures[itemType], screenX, screenY);
                                ctx.globalAlpha = 1.0;
                            }
                        } else {
                            const adjacent = [
                                `${blockX+1},${blockY}`,
                                `${blockX-1},${blockY}`,
                                `${blockX},${blockY+1}`,
                                `${blockX},${blockY-1}`
                            ];
                            
                            let canPlace = false;
                            for (const key of adjacent) {
                                if (terrain[key] || vegetation[key]) {
                                    canPlace = true;
                                    break;
                                }
                            }
                            
                            if (canPlace) {
                                ctx.globalAlpha = 0.6;
                                ctx.drawImage(
                                    blockTextures[itemType],
                                    blockX * TILE - camera.x,
                                    blockY * TILE - camera.y
                                );
                                ctx.globalAlpha = 1.0;
                            }
                        }
                    }
                }
            }
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
    
  </body>
  
</html>
